var ecoAI = require('eco.AI');
// Module designs creep bodies for creeps in various roles. Each role has a body generated by a function in this module.

var bodyBuilder = {
    
    // Sets the Memory object if it is not defined, then computes the bodies at each step.
    run:function(SpawnLoc){
        
        if(Memory.creepBody == undefined){
            Memory.creepBody = {}
        }
        if(Memory.creepBody[SpawnLoc.room.name] == undefined){
            Memory.creepBody[SpawnLoc.room.name] = {}
        }
        
        // Try to set every body type to the correct value.
        Memory.creepBody[SpawnLoc.room.name]['miner'] = bodyBuilder.largest_miner(SpawnLoc);
        
        Memory.creepBody[SpawnLoc.room.name]['transport'] = bodyBuilder.largest_transport(SpawnLoc);
        
        Memory.creepBody[SpawnLoc.room.name]['upgrader'] = bodyBuilder.largest_upgrader(SpawnLoc)
        
        Memory.creepBody[SpawnLoc.room.name]['worker'] = bodyBuilder.largest_worker(SpawnLoc)
        
        Memory.creepBody[SpawnLoc.room.name]['collector'] = bodyBuilder.MineralCollector(SpawnLoc)
        
          
    },
    
    // Build the largest transport the room can. optionally a station (room name as a string) is provided then make a different body.
    largest_transport:function(SpawnLoc,station = undefined,cap = 600,report = false,roads = false){
        
        var Fatigue = 0;
        
        var room_development = SpawnLoc.room.energyCapacityAvailable;
        
        var transport_body = new Array(CARRY,MOVE);
        
        
        var move_cost = 2;
        if(roads){
            move_cost = 1;
        }
        
        
        
        // If the station is defined we know we need to check if it has roads or not.
        if(station){
            
            // A road is established in the case that Memory.road_network is true
            
            if(Memory.road_network[station] == true){
                transport_body =  [WORK,CARRY,MOVE,MOVE];
                move_cost = 1;
            } else if(Memory.road_network[station] == false){
                transport_body =  [WORK,WORK,CARRY,MOVE,MOVE,MOVE];
                move_cost = 2;
            }
        
        }
        
        var cost_of_transport = ecoAI.bodyCost(transport_body);
        
        while(cost_of_transport < Math.min(room_development,cap) && transport_body.length < 20){
            
            transport_body.push(CARRY);
            cost_of_transport += 50 + move_cost*25;
            
            Fatigue += move_cost;
            

        }
        
        while(Fatigue > 0){
            transport_body.push(MOVE);
            cost_of_transport += 50;
            Fatigue = Fatigue - 2;
        }
        
        
        transport_body.sort()
        
        if(report){
            console.log("New transport body algorithm gives"+JSON.stringify(transport_body))
            if(station){
                console.log(' when dealing with a remote source mine at '+station +' where roads exist is '+Memory.road_network[station])
            }
        }
        return transport_body
    },
    // Build the largest miner the room can.
    largest_miner:function(SpawnLoc){
        
        var room_development = SpawnLoc.room.energyCapacityAvailable;
        
        var miner_body = new Array(CARRY);
        
        var cost_of_miner = ecoAI.bodyCost(miner_body);
        
        var flip = true;
        
        var work_parts = 0;
        
        var Fatigue = 2;
        
        while(cost_of_miner < room_development -100 && work_parts < 6 && miner_body.length < 25){
            
            if(Fatigue > 0){
                miner_body.push(MOVE);
                cost_of_miner += 50;
                Fatigue = Fatigue -2;
            }
            else{
                miner_body.push(WORK);
                cost_of_miner += 100;
                work_parts += 1;
                Fatigue += 2;
            } 
        }
        
        while(Fatigue > 0){
            miner_body.push(MOVE);
            cost_of_miner += 50;
            Fatigue = Fatigue -2;
        }
        
        return miner_body.sort()
    },
    // Largest upgrader, if roads is false then it needs a move part per each other part
    largest_upgrader:function(SpawnLoc,roads = true,budget = 2000,report = false){
        
        var max_work_parts = Math.ceil(budget/300)
        
        var cur_room = SpawnLoc.room;
        
        var room_development = cur_room.energyCapacityAvailable;
        
        var upgrader_body = new Array(CARRY,MOVE);
        
        var expected_travel = ecoAI.upgradeDistance(cur_room.name)
        
        var cost_of_upgrader = ecoAI.bodyCost(upgrader_body);
        
        var move_cost = 2;
        
        var Fatigue = 0;
        
        if(roads){
            var Fatigue = -1;
            move_cost = 1;
        }
        
        var work_parts = 0;
        
        var count_to_carry = 0;
        
        while(cost_of_upgrader < room_development - 100 && work_parts < max_work_parts && upgrader_body.length < 48){
            
            // Every 4th work part add a carry part instead of a work part && If the upgrader never has to move (useing the ecoAI.upgradeDistance function) dont add carry parts
                
            if (count_to_carry == 4 && expected_travel > 0){
                count_to_carry = 0;
                upgrader_body.push(CARRY);
            
                cost_of_upgrader += 50;
                
                Fatigue += move_cost;

            }
            else{
                upgrader_body.push(WORK);
                
                cost_of_upgrader += 100;

                Fatigue += move_cost;

                work_parts += 1;
                count_to_carry += 1;
            }
            
            while(Fatigue > 0){
                upgrader_body.push(MOVE);
                cost_of_upgrader += 50;
                Fatigue = Fatigue -2;
            }
        }
        
        if(report){
            console.log(upgrader_body.sort() +'\n'
            +'cost '+ecoAI.bodyCost(upgrader_body) +'\n'
            +'capacity '+room_development)  
        }

        return upgrader_body.sort();

    },
    // Largest milita the room can currently build, if roads is false then it needs a move part per each other part
    largest_milita:function(SpawnLoc,report = false){
        
        var cur_room = SpawnLoc.room;
        
        var room_development = cur_room.energyAvailable;
        
        var milita_body = new Array(MOVE,MOVE,ATTACK,RANGED_ATTACK);
        
        var cost_of_milita = ecoAI.bodyCost(milita_body);
        
        var Fatigue = 0;

        var attack_parts = 0;
        
        
        while(cost_of_milita < room_development - 200 && milita_body.length < 50){
            

            // Every 2nd ranged part add a attack part instead of a work part
            if (attack_parts == 1){
                attack_parts = 0;
                milita_body.push(ATTACK);
            
                cost_of_milita += 80;
                Fatigue += 2;
                
            }
            else{
                milita_body.push(RANGED_ATTACK);
                
                cost_of_milita += 150;
                Fatigue += 2;
                
                attack_parts += 1;
            }
            
            while(Fatigue > 0){
                milita_body.push(MOVE);
                cost_of_milita += 50;
                Fatigue = Fatigue -2;
            }
        }
        if(report){
            console.log(milita_body.sort())
            console.log('cost '+ecoAI.bodyCost(milita_body))
            console.log('capacity '+room_development)
        }
        return milita_body.sort();

    },
    
    // Largest worker/ maintainer/ builder
    MineralCollector:function(SpawnLoc,roads = false,max_work_parts = 25,report = false){
        
        var cur_room = SpawnLoc.room;
        
        var room_development = cur_room.energyCapacityAvailable;
        
        var collector_body = new Array(CARRY,MOVE);
        
        var body_cost = ecoAI.bodyCost(collector_body);
        
        var move_cost = 2;
        
        var Fatigue = 0;
        
        if(roads){
            var Fatigue = -1;
            move_cost = 1;
        }
        
        var work_parts = 0;
        
        while(body_cost < room_development - 100 && work_parts < max_work_parts && collector_body.length < 50){
            

            collector_body.push(WORK);
            
            body_cost += 100;
            
            Fatigue += move_cost;
            
            work_parts += 1;
            
            
            while(Fatigue > 0){
                collector_body.push(MOVE);
                body_cost += 50;
                Fatigue = Fatigue -2;
            }
        }
        
        if(report){
            console.log(collector_body.sort() +'\n'
            +'cost '+ecoAI.bodyCost(body_cost) +'\n'
            +'capacity '+room_development)
            
        }
        
        return collector_body.sort();

    },
    largest_worker:function(SpawnLoc,roads = false,max_work_parts = 10,report = false,max_size = 34){
        
        var cur_room = SpawnLoc.room;
        
        var room_development = cur_room.energyCapacityAvailable;
        
        var worker_body = new Array(CARRY,MOVE);
        
        var body_cost = ecoAI.bodyCost(worker_body);
        
        var move_cost = 2;
        
        var Fatigue = 0;
        
        if(roads){
            var Fatigue = -1;
            move_cost = 1;
        }
        
        var work_parts = 0;
        
        while(body_cost < room_development - 100 && work_parts < max_work_parts && worker_body.length < max_size){
            // For every 2 work parts attach a carry part.
            if(work_parts == 2){
                worker_body.push(CARRY);
                Fatigue += move_cost;
                body_cost += 50;
                work_parts = 0;
                
            }else{
                worker_body.push(WORK);
                body_cost += 100;
                Fatigue += move_cost;
                work_parts += 1;
            }
            
            while(Fatigue > 0){
                worker_body.push(MOVE);
                body_cost += 50;
                Fatigue = Fatigue -2;
            }
        }
        
        if(report){
            console.log(worker_body.sort() +'\n'
            +'cost '+ecoAI.bodyCost(body_cost) +'\n'
            +'capacity '+room_development)
            
        }
        
        return worker_body.sort();

    },
    
    
    
    
    largest_worker_old:function(SpawnLoc){
        
        
        
        var cur_room = SpawnLoc.room;
        
        var cur_controler = cur_room.controller;
        
        var room_development = cur_room.energyCapacityAvailable;
        
        var worker_body_by_RCL =   {1:[WORK,WORK,CARRY,MOVE],
                        2:[WORK,WORK,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE], // The end of teir 2
                        3:[WORK,WORK,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE],//Max energy for RCL 3
                        4:[WORK,WORK,WORK,WORK,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],
                        5:[WORK,WORK,WORK,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],
                        6:[WORK,WORK,WORK,WORK,WORK,WORK,CARRY,CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],
                        7:[WORK,WORK,WORK,WORK,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],
                        8:[WORK,WORK,WORK,WORK,WORK,WORK,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE],
        };

        var workerBody = worker_body_by_RCL[cur_controler.level];

        if(ecoAI.bodyCost(workerBody) > room_development){
            var workerBody = worker_body_by_RCL[cur_controler.level -1] || [WORK,WORK,CARRY,MOVE];
        }
        
        return workerBody.sort()
    },
    
    // Compute the cost of a given creep body.
    bodyCost:function(body){
        var partCost = {work:100,carry:50,move:50,tough:10,claim:600,attack:80,ranged_attack:150,heal:250};
        var total = 0;
        for(var i = 0; i<body.length; i++){
            total = total + partCost[body[i]]; 
            
        }
        return total;
    },
    
    
     /**
     * Add element(s) to a elements. If not all elements can be added it will add none.
     *
     * @param {string|Array} elements Element(s) to add to the elements containing part names
     * @returns {boolean}
     */
    addToDesign(elements){
        if(elements instanceof Array){
            var budgetLeft = this.budget;
            if((elements.length + this.elements.length) > 50) return false;

            for(var itm of elements){
                if (BODYPART_COST[itm] < budgetLeft) {
                    budgetLeft -= BODYPART_COST[itm];
                } else return false;
            }
            this.budget = budgetLeft;
            this.elements = this.elements.concat(elements);
        }
        else {
            if(this.elements.length > 49) return false;
            if (BODYPART_COST[elements] > this.budget) return false;

            this.budget -= BODYPART_COST[elements];
            this.elements.push(elements);
        }
        return true;
    }
    
    
    
    
    
}


module.exports = bodyBuilder;
